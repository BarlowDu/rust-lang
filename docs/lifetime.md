## Rust中的每一个引用都有其生命周期(lifetime),也就是引用保持有效的作用域.

大部分时候生命周期是隐含并可以推断的,正如大部分时候类型也是可以推断的一样.类似于当因为有多种可能类型的时候必须注明类型,也会出现引用的生命周期以一些不同方式相关联的情况,所以Rust需要我们使用泛型生命周期参数来注明他们的关系,这样就能确保运行时实际使用的引用绝对是有效的.

生命周期的概念某种程度上说不同于其他语言中类似的工具,毫无疑问这是Rust最与众不同的功能.

Rust编译器有一个借用检查器(borrow checker),它比较作用域来确保所有的借用都是有效的.
```
{
let r;                  // ---------+-- 'a
                        //          |
{                       //          |
let x = 5;              // -+-- 'b  |
r = &x;                 //  |       |
}                       // -+       |
                        //          |
println!("r: {}", r);   //          |
}                       // ---------+
```
在编译时,Rust比较这两个生命周期的大小,并发现r拥有生命周期'a,不过它引用了一个拥有生命周期'b的对象.程序被拒绝编译,因为生命周期'b比生命周期'a要小:**被引用的对象比它的引用者存在的时间更短**

### 函数中的泛型生命周期

```
fn longest(x:&str,y:&str)->&str{
    if x.len()>y.len(){
        x
    }else{
        y
    }
}
```
上述代码存在的问题,x,y的生命同期可能不一致,在不一致的情况下该方法的返回值的生命周期也将不确定.

    生命周期注解的意义是不是在函数的引用参数与返回值构建一套规则,借用检查器按此规则来进行检查???

### 生命同期注解语法
生命周期注解并不改变任何引用的生命周期的长短.与当函数签名中指定了泛型类型参数后就可以接受任何类型一样,当指定了泛型生命周期后函数也能接受任何生命周期的引用.生命周期注解描述了多个引用生命周期相互的关系,而不影响其生命周期.

生命周期注解有着一个不太常见的语法:生命周期参数名称必须以撇号(')开头,其名称通常全是小写,类似于泛型其名称非常短.'a是大多数人默认使用的名称.生命周期参数注解位于引用的&之后,并有一个空格来将引用类型与生命周期注解分隔开.


