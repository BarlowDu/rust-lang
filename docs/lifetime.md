# 生命周期与引用有效性

> Rust中的每一个引用都有其生命周期(lifetime),也就是引用保持有效的作用域.

大部分时候生命周期是隐含并可以推断的,正如大部分时候类型也是可以推断的一样.类似于当因为有多种可能类型的时候必须注明类型,也会出现引用的生命周期以一些不同方式相关联的情况,所以Rust需要我们使用泛型生命周期参数来注明他们的关系,这样就能确保运行时实际使用的引用绝对是有效的.

生命周期的概念某种程度上说不同于其他语言中类似的工具,毫无疑问这是Rust最与众不同的功能.

Rust编译器有一个**借用检查器**(*borrow checker*),它比较作用域来确保所有的借用都是有效的.
```rust
{
let r;                  // ---------+-- 'a
                        //          |
{                       //          |
let x = 5;              // -+-- 'b  |
r = &x;                 //  |       |
}                       // -+       |
                        //          |
println!("r: {}", r);   //          |
}                       // ---------+
```
*示例:1*

在编译时,Rust比较这两个生命周期的大小,并发现`r`拥有生命周期`'a`,不过它引用了一个拥有生命周期`'b`的对象.程序被拒绝编译,因为生命周期'b比生命周期'a要小:**被引用的对象比它的引用者存在的时间更短**

## 函数中的泛型生命周期

```
fn longest(x:&str,y:&str)->&str{
    if x.len()>y.len(){
        x
    }else{
        y
    }
}
```
complie error:
```
error[E0106]: missing lifetime specifier
--> src/main.rs:1:33
|
1 | fn longest(x: &str, y: &str) -> &str {
| ^ expected lifetime parameter
|
= help: this function's return type contains a borrowed value, but the
signature does not say whether it is borrowed from `x` or `y`
//注意help信息:返回结果为引用类型,但是没有说明它是借用于参数x还是y
```
上述代码存在的问题,`x`,`y`的生命同期可能不一致,在不一致的情况下该方法的返回值的生命周期也将不确定.

>> 生命周期注解的意义是不是在函数的引用参数与返回值构建一套规则(当返回值依赖参数时),借用检查器按此规则来进行检查???

>> 因为函数不可能返回生成一个新数据的引用,所以返回值为引用类型的情况下必定与参数有关


## 生命同期注解语法
生命周期注解并不改变任何引用的生命周期的长短.与当函数签名中指定了泛型类型参数后就可以接受任何类型一样,当指定了泛型生命周期后函数也能接受任何生命周期的引用.生命周期注解描述了多个引用生命周期相互的关系,而不影响其生命周期.

生命周期注解有着一个不太常见的语法:生命周期参数名称必须以撇号(')开头,其名称通常全是小写,类似于泛型其名称非常短.`'a`是大多数人默认使用的名称.生命周期参数注解位于引用的&之后,并有一个空格来将引用类型与生命周期注解分隔开.


> 单个生命周期注解本身没有多少意义,因为生命周期注解告诉Rust多个引用的泛型生命周期参数如何相互联系.例如如果函数有一个生命周期`'a`的`i32`的引用参数`first`.还有另一个同样是生命周期`'a`的`i32`的引用的参数`second`.这两个生命周期注解意味着引用`first`和`second`必须与这泛型生命周期存在得一样久.

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```
*示例:2*

现在函数签名表明对于某些生命周期`'a`函数会获取两个参数,他们都是与生命周期`'a`存在的一样长的字符串slice.函数会返回一个同样也与生命周期`'a`存在的一样长的字符串slice.这就是我们告诉Rust需要其保证的契约.记住通过在函数签名中指定生命周期参数时,我们并没有改变任何传入后返回的值的生命周期.而是指出任何不遵守这个协议的传入值都将被借用检查器拒绝.注意`longest`函数并不需要知道`x`和`y`具体会存在多久,而只需要知道有某个可以被`'a`替代的作用域将会满足这个签名.

当在函数中使用生命周期注解时,这些注解出现在函数签名中,而不存在于函数体中的任何代码的,这是因为Rust能够分析函数中代码而不需要任何协助,不过当函数引用或被函数之外的代码引用是时,让Rust自身分析出参数或者返回值的生命周期几乎是不可能的,这些生命周期在每次函数被调用时都可能不同,这也就是为什么我们需要手动标记生命周期.

当具体的引用被传递给`longest`时,被`'a`所替代的生命周期是`x`的作用域与`y`的作用域**相重叠**的那一部分.换一种说法就是泛型生命周期`'a`的具体生命周期等同于`x`和`y`的生命周期中较小的那一个.因为我们用相同的生命周期参数`'a`标注了返回的引用值,所以返回的引用值就是保证在`x`和`y`中较短的那个生命周期结束之前保持有效.


## 深入理解生命周期

指定生命周期参数的正确方式依赖函数实现的具体功能.例如,如果将`longest`函数的实现修改为问题返回第一个参数而不是最长的

> 生命周期语法是用于将函数的多个参数与其返回值的生命周期进行关联的.一旦他们形成了关联.Rust就有了足够的信息来允许内存安全的操作并阻止会产生的悬垂指针亦或违反内存安全的行为.


### 结构体中的生命周期注解

```rust
struct ImportantExcerpt<'a>{
    part:'a &str,
}
fn main(){
    let novel=String::From("call me Ishmael.Some years ago...");
    let first_sentence=novel.split('.')
        .next()
        .expect("Could not find a '.'");
        let i=ImportantExcerpt{part:first_sentence};
}
```
*示例:3*

这个结构体有一个字段part,它存放了一个字符串slice,这是一个引用.类似于泛型参数类型,必须在结构体名称后面的尖括号中声明泛型生命周期,以便在结构体中定义使用生命周期参数.这个注解意味着ImportantExcerpt的实例不能比其part字段中的引用存在的更久.


## 生命周期省略(Lifetime Elision)

现在我们已经知道了第一个引用都有一个生命周期,而且我们需要为那些使用了引用的函数或者结构体指定生命周期.下面的函数没有生命周期注解却能编译成功(见第四章):
```rust
fn first_word(s:&str)->&str{
    let bytes=s.as_bytes();

    for(i,&item) in bytes.iter().enumerate(){
        if item==b' '{
            return &s[0..i]
        }
    }
    &s[..]
}
```
*示例:4*

这个函数没有生命周期注解却能编译,是由于一些历史原因:在早期版本(pre-1.0)的Rust中,这的确是不能编译的.第一个引用必须有明确的生命周期.那时函数签名将会写成这样:
```rust
fn first_word<'a>(s:&'a str){}
```
在编写了很多Rust代码后,Rust团队发现在特定情况下Rust程序员总是重复地编写一模一样的生命周期注解.这些场景是可预测的并且遵循内个明确的模式.接着Rust团队就把这些模式编码进了Rust编译器,如此借用检查器在这些情况下就能推断出生命周期而不再强制程序员显式的增加注解.

这里我们提到一些Rust历史是因为更多的明确的模式被合并和添加到编译器中是完成可能的.未来只会需要更少的生命周期注解.

被编码进Rust引用分析的模式被称为**生命周期省略规则**(*lifetime elision rules*).这并不是需要程序员遵守的规则;这些规则是一系列特定的场景,此时编译器会考虑,如果代码符合这些场景,就无需明确指定生命周期.

省略规则并不提供完整的推断:如果Rust在明确遵守这些规则的前提下变量的生命周期仍然是模棱两可的话,它不会猜测剩余引用的生命周期应该是什么.在这种情况,编译器会给出一个错误,这可以通过增加对应引用之间相联系的生命周期注解来解决.


函数或者方法的参数的生命周期被称为**输入生命周期**(*input lifetime*),而返回值的生命周期被称为**输出生命周期**(*out lifetime*).

编译器采用三条规则来判断引用何时是不需要明确的注解.第一条规则适用于输入生命周期,后两条规则适用于输出生命周期.如果编译器检查完这三条规则仍然没有计算出生命周期引用,编译将会停止并生成错误.

这些规则适用于`fn`定义,以及`impl`块.

* 第一条规则是每一个引用的参数都有它自己的生命周期参数.换句话说就是,有一个引用参数的函数有一个生命周期:`fn foo<'a>(x:&'a i32)`,有两个引用参数的函数有两个不同的生命周期,`fn foo<'a,'b>(x:&'a i32,y:&'b i32)`,依此类推.

* 第二条规则是如果只有一个输入生命周期参数,那么它被赋予所有输出生命周期参数:`fn foo<'a>(x:&'a i32)->&'a i32`.

* 第三条规则是如果方法有多个输入生命周期参数,不过其中之一因为方法的缘故为`&self`或者`&mut self`,那么`self`的生命周期被赋给所有输出生命周期参数.这使得方法更容易读写,因为只需要更少的符号.


假设我们自己就是编译器.并应用这些规则来计算`first_word`函数签名中的引用的生命周期.开始时签名中的引用并没有关联任何生命周期:
```text
fn first_word(s:&str)->&str{
```
接着编译器应用第一条规则,也就是每个引用参数都其自己的生命周期.我们像往常一样称之为`'a`,所以现在签名看起来像这样:
```text
fn first_word<'a>(s:&'a str)->&'a str{
```
现在这个函数签名中的所有引用都有了生命周期,如此编译器可以继续它的分析而无需程序员标记这个函数签名中的生命周期.

让我们再看看另一个例子,这次示例的是没有生命周期参数的`longest`函数:
```text
fn longest(x:&str,y:&str)->&str{
```
再次假设我们自己就是编译器并应该第一条规则:每个引用参数都有其自己的生命周期.这次有两个参数,所以就有两个(不同的)生命周期:
```text
fn longest<'a,'b>(x:&'a str,y:&'b str)->&str{
```
再来应用第二条规则,因为函数存在多个输入生命周期,它并不适用于这种情况.再来看第三条规则,它同样也不适用,这是因为没有`self`参数.应用了三个规则之后编译器还没有计算出返回值类型的生命周期.这就是为什么在上述声明时编译器会报错的原因:编译器使用所有已知的生命周期省略规则,仍不能计算出签名中所有引用的生命周期.

## 方法定义中的生命周期注解

当为带有生命周期的结构休实现方法时,其语法依然类似于泛型类型参数的语法.声明和使用生命周期参数的位置依赖于生命周期参数是否同结构体字段或方法参数的返回值相关.

`impl`块里的方法签名中,引用可能与结构体字段中的引用相关联,也可能是独立的.另外,生命周期省略规则也经常让我们无需在方法 签名中使用生命周期注解.让我们看看一些使用*示例:3*中定义的结构体`ImportantExcerpt`的例子.

首先,这里有一个方法`level`.其唯一的参数是`self`引用,而且返回值只是一个`i32`,并不引用任何值:

```rust
#struct ImportantExcerpt<'a>{
#    part:&'a str,
#}
#
impl<'a> ImportantExcerpt<'a>{
    fn level(&self)->i32{
        3
    }
}
```
*示例:5*

impl 之后和类型名称之后的生命周期参数是必要的,不过因为第一条生命周期规则我们并不必须标注`self`引用的生命周期.

这里是一个适用第三条生命周期省略规则的例子:

```rust
#struct ImportantExcerpt<'a>{
#    part:&'a str,
#}
#

impl<'a> ImportantExcerpt<'a>{
    fn announce_and_return_part(&self,announcement:&str)->&str{
        println!("Attention please:{}",announcement);
        self.part
    }
}
```
*示例:6*

这里有两个输入生命周期,所以Rust应用第一条生命周期规则并给予`&self`和`announcement`他们各自的生命周期,接着,因为其中一个参数是`&self`,返回值类型被赋予了`&self`的生命周期,这样所有的生命周期都被计算出来了.

## 静态生命周期

这里有一种特殊的生命周期值得讨论:`'static`,其生命周期存活于整个程序期间.所有的字符器字面值都拥有`'static`生命周期,我们也可以选择像下面亮相标注出来:

```rust
let s:&'static str="I have a static lifetime";
```

这个字符串的文本被直接储存在程序的二进制文件中而这个文件总是可用的,因此所有的字符串字面值都是`'static`的.

你可能在错误信息的帮助文件中见过使用`'static`生命周期的建议,不过将引用指定为`'static`之前,思考一下这个引用是否真的在整个生命周期里都有效.你可能会考虑希望它一直有效,如果可能的话.大部分情况,代码中问题是尝试创建一个悬垂引用或者可用的生命周期不匹配,请解决这些这些问题而不是指定一个`'static`的生命周期.

## 结合泛型类型参数,trait bounds和生命周期

让我们简要的看一下在同一个函数中指定泛型类型参数,trait bounds和生命周期的语法!

```rust
use std::fmt::Display;

fn longest_with an announcement<'a,T>(x:&'a str,y:&'a str,ann:T)->&a' str
where T:Display
{
    println!("Announcement!{}",ann);
    if x.len()>y.len(){
        x
    }else{
        y
    }
}
```
*示例:7*

这个示例对比之前的`longest`函数,不过带有一个额外的参数`ann`.`ann`的类型是泛型`T`,它可以被放入任何实现了`where`从句中指定的`Display`trait的类型.这个额外的参数会在函数比较字符串slice的长度之前被打印出来,这也就是为什么`Display`trait bound是必须的.因为生命周期也是泛型,所以生命周期参数`'a`和泛型类型参数`T`都位于函数名后的同一个尖括号列表中.



