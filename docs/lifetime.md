## Rust中的每一个引用都有其生命周期(lifetime),也就是引用保持有效的作用域.

大部分时候生命周期是隐含并可以推断的,正如大部分时候类型也是可以推断的一样.类似于当因为有多种可能类型的时候必须注明类型,也会出现引用的生命周期以一些不同方式相关联的情况,所以Rust需要我们使用泛型生命周期参数来注明他们的关系,这样就能确保运行时实际使用的引用绝对是有效的.

生命周期的概念某种程度上说不同于其他语言中类似的工具,毫无疑问这是Rust最与众不同的功能.

Rust编译器有一个**借用检查器**(*borrow checker*),它比较作用域来确保所有的借用都是有效的.
```rust
{
let r;                  // ---------+-- 'a
                        //          |
{                       //          |
let x = 5;              // -+-- 'b  |
r = &x;                 //  |       |
}                       // -+       |
                        //          |
println!("r: {}", r);   //          |
}                       // ---------+
```
*示例:1*

在编译时,Rust比较这两个生命周期的大小,并发现`r`拥有生命周期`'a`,不过它引用了一个拥有生命周期`'b`的对象.程序被拒绝编译,因为生命周期'b比生命周期'a要小:**被引用的对象比它的引用者存在的时间更短**

### 函数中的泛型生命周期

```
fn longest(x:&str,y:&str)->&str{
    if x.len()>y.len(){
        x
    }else{
        y
    }
}
```
complie error:
```
error[E0106]: missing lifetime specifier
--> src/main.rs:1:33
|
1 | fn longest(x: &str, y: &str) -> &str {
| ^ expected lifetime parameter
|
= help: this function's return type contains a borrowed value, but the
signature does not say whether it is borrowed from `x` or `y`
//注意help信息:返回结果为引用类型,但是没有说明它是借用于参数x还是y
```
上述代码存在的问题,`x`,`y`的生命同期可能不一致,在不一致的情况下该方法的返回值的生命周期也将不确定.

>> 生命周期注解的意义是不是在函数的引用参数与返回值构建一套规则(当返回值依赖参数时),借用检查器按此规则来进行检查???

>> 因为函数不可能返回生成一个新数据的引用,所以返回值为引用类型的情况下必定与参数有关


### 生命同期注解语法
生命周期注解并不改变任何引用的生命周期的长短.与当函数签名中指定了泛型类型参数后就可以接受任何类型一样,当指定了泛型生命周期后函数也能接受任何生命周期的引用.生命周期注解描述了多个引用生命周期相互的关系,而不影响其生命周期.

生命周期注解有着一个不太常见的语法:生命周期参数名称必须以撇号(')开头,其名称通常全是小写,类似于泛型其名称非常短.`'a`是大多数人默认使用的名称.生命周期参数注解位于引用的&之后,并有一个空格来将引用类型与生命周期注解分隔开.


> 单个生命周期注解本身没有多少意义,因为生命周期注解告诉Rust多个引用的泛型生命周期参数如何相互联系.例如如果函数有一个生命周期`'a`的`i32`的引用参数`first`.还有另一个同样是生命周期`'a`的`i32`的引用的参数`second`.这两个生命周期注解意味着引用`first`和`second`必须与这泛型生命周期存在得一样久.

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```
*示例:2*

现在函数签名表明对于某些生命周期`'a`函数会获取两个参数,他们都是与生命周期`'a`存在的一样长的字符串slice.函数会返回一个同样也与生命周期`'a`存在的一样长的字符串slice.这就是我们告诉Rust需要其保证的契约.记住通过在函数签名中指定生命周期参数时,我们并没有改变任何传入后返回的值的生命周期.而是指出任何不遵守这个协议的传入值都将被借用检查器拒绝.注意`longest`函数并不需要知道`x`和`y`具体会存在多久,而只需要知道有某个可以被`'a`替代的作用域将会满足这个签名.

当在函数中使用生命周期注解时,这些注解出现在函数签名中,而不存在于函数体中的任何代码的,这是因为Rust能够分析函数中代码而不需要任何协助,不过当函数引用或被函数之外的代码引用是时,让Rust自身分析出参数或者返回值的生命周期几乎是不可能的,这些生命周期在每次函数被调用时都可能不同,这也就是为什么我们需要手动标记生命周期.

当具体的引用被传递给`longest`时,被`'a`所替代的生命周期是`x`的作用域与`y`的作用域**相重叠**的那一部分.换一种说法就是泛型生命周期`'a`的具体生命周期等同于`x`和`y`的生命周期中较小的那一个.因为我们用相同的生命周期参数`'a`标注了返回的引用值,所以返回的引用值就是保证在`x`和`y`中较短的那个生命周期结束之前保持有效.


### 深入理解生命周期

指定生命周期参数的正确方式依赖函数实现的具体功能.例如,如果将`longest`函数的实现修改为问题返回第一个参数而不是最长的

> 生命周期语法是用于将函数的多个参数与其返回值的生命周期进行关联的.一旦他们形成了关联.Rust就有了足够的信息来允许内存安全的操作并阻止会产生的悬垂指针亦或违反内存安全的行为.


### 结构体中的生命周期注解

```rust
struct ImportantExcerpt<'a>{
    part:'a &str,
}
fn main(){
    let novel=String::From("call me Ishmael.Some years ago...");
    let first_sentence=novel.split('.')
        .next()
        .expect("Could not find a '.'");
        let i=ImportantExcerpt{part:first_sentence};
}
```
*示例:3*

这个结构体有一个字段part,它存放了一个字符串slice,这是一个引用.类似于泛型参数类型,必须在结构体名称后面的尖括号中声明泛型生命周期,以便在结构体中定义使用生命周期参数.这个注解意味着ImportantExcerpt的实例不能比其part字段中的引用存在的更久.


### 生命周期省略(Lifetime Elision)

现在我们已经知道了第一个引用都有一个生命周期,而且我们需要为那些使用了引用的函数或者结构体指定生命周期.下面的函数没有生命周期注解却能编译成功(见第四章):
```rust
fn first_word(s:&str)->&str{
    let bytes=s.as_bytes();

    for(i,&item) in bytes.iter().enumerate(){
        if item==b' '{
            return &s[0..i]
        }
    }
    &s[..]
}
```
*示例:4*

这个函数没有生命周期注解却能编译,是由于一些历史原因:在早期版本(pre-1.0)的Rust中,这的确是不能编译的.第一个引用必须有明确的生命周期.那时函数签名将会写成这样:
```rust
fn first_word<'a>(s:&'a str){}
```
在编写了很多Rust代码后,Rust团队发现在特定情况下Rust程序员总是重复地编写一模一样的生命周期注解.这些场景是可预测的并且遵循内个明确的模式.接着Rust团队就把这些模式编码进了Rust编译器,如此借用检查器在这些情况下就能推断出生命周期而不再强制程序员显式的增加注解.

这里我们提到一些Rust历史是因为更多的明确的模式被合并和添加到编译器中是完成可能的.未来只会需要更少的生命周期注解.

被编码进Rust引用分析的模式被称为**生命周期省略规则**(*lifetime elision rules*).这并不是需要程序员遵守的规则;这些规则是一系列特定的场景,此时编译器会考虑,如果代码符合这些场景,就无需明确指定生命周期.

省略规则并不提供完整的推断:如果Rust在明确遵守这些规则的前提下变量的生命周期仍然是模棱两可的话,它不会猜测剩余引用的生命周期应该是什么.在这种情况,编译器会给出一个错误,这可以通过增加对应引用之间相联系的生命周期注解来解决.


函数或者方法的参数的生命周期被称为**输入生命周期**(*input lifetime*),而返回值的生命周期被称为**输出生命周期**(*out lifetime*).

编译器采用三条规则来判断引用何时是不需要明确的注解.第一条规则适用于输入生命周期,后两条规则适用于输出生命周期.如果编译器检查完这三条规则仍然没有计算出生命周期引用,编译将会停止并生成错误.

这些规则适用于`fn`定义,以及`impl`块.

第一条规则是第一个引用的参数都有它自己的生命周期参数.换句话说就是,有一个引用参数的函数有一个生命周期:`fn foo<'a>(x:&'a i32)`,有两个引用参数的函数有两个不同的生命周期,`fn foo<'a,'b>(x:&'a i32,y:&'b i32)`,依此类推.

第二条规则是如果只有一个输入生命周期参数,那么它被赋予所有输出生命周期参数:`fn foo<'a>(x:&'a i32)->&'a i32`.

第三条规则是如果方法有多个输入生命周期参数,不过其中之一因为方法的缘故为`&self`或者`&mut self`,那么`self`的生命周期被赋给所有输出生命周期参数.这使得方法更容易读写,因为只需要更少的符号.








