# 智能指针

指针(*pointer*)是一个包含内存地址的变量的通用概念.这个地址引用,或"指向"(points at)一些其他数据.Rust中最常见的指针是引用(*reference*).引用以`&`符号为标志并借用了他们指向的值.除了引用数据没有任何其他特殊功能.它们也没有任何额外开销,所以应用的最多.

另一方面.智能指针(*smart pointer*)是一类数据结构,他们的表现类似指针,但是也拥有额外的元数据和功能.智能指针的概念并不为Rust所独有;其起源于C++并存在于其他语言中.Rust标准库中不同的智能指针提供了多于引用的额外功能.本章将会探索的一个例子便是**引用记数**(*reference counting*)智能指针类型,其允许数据有多个所有者.引用计数智能指针记录总共有多少个所有者,并当没有任何所有者时负责清理数据.

在Rust中,普通引用和智能指针的一个额外的区别是引用是一类只借用数据的指针;相反大部分情况下,智能指针 拥有他们指向的数据.

实际上已经出现过一些智能指针,比如`String`和`Vec<T>`,虽然当时我们并不这么称呼它们.这些类型都属于智能指针因为它们拥有一些数据并允许你修改它们.它们也带有无数据(比如他们的容量)我额外的功能或保证(`String`的数据总是有效的UTF-8编码).

智能指针通常使用结构体实现.智能指针区别于常规结构体的显著特性在于其实现了`Deref`和`Drop`trait.`Deref`trait允许智能指针结构体实例表现的像引用一样,这样就可以编写既用于引用又用于智能指针的代码.`Drop`trait允许我们自定义当智能指针离开作用域时运行的代码.

考虑到智能指针是一个在Rust经常被使用的通用设计模式,很多库都有自己的智能指针而你也可能编写属于你自己的智能指针.

常用的智能指针:
* `Box<T>`,用于在堆上分配值
* `Rc<T>`,一个引用计数类型,其数据可以有多个所有者
* `Ref<T>`和`RefMut<T>`,通过`RefCell<T>`访问,一个运行时也不是在编译时执行的借用规则类型

另外会涉及**内部可变性**(*interior mutablility*)模式,这时不可变类型暴露出改变其内部值的API.**引用循环**(*reference cycles*)会如何泄露内存,以及如何避免

### `Box<T>`在堆上存储数据,并且可确定大小

最简单直接的智能指针是box,其类型是`Box<T>`.box允许你将一个值放在堆上而不是栈上.留在栈上的则是指向堆数据的指针.

除了数据被存储在堆上而不是栈上之外,box没有性能损失.不过也没有很多额外的功能.它们多用于如下场景:
* 当有一个在编译时未知大小的类型,而又想要在需要确切大小的上下文中使用这个类型值的时候
* 当有大量数据并希望确保数据不被拷贝的情况下转移所有权的时候
* 当希望拥有一个值并只关心它的类型是否实现了特定trait而不是其具体类型的时候
