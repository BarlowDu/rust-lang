1. Rust倾向于确保暴露出可能的错误,
2. 字符串是比很多程序员所想象的要更为复杂的数据结构,以及UTF-8

字符串就是作为字节的集合外加一些方法实现的,当这些字节被解释为文本时,这些方法提供了实用的功能.在这一部分,

称作`String`的类型是由标准库提供的,而没有写进核心语言部分,它是可增长的,可变的,有所有权的,UTF-8编码的字符串类型.当Rustacean们谈到Rust的"字符串"时,它们通常指的是`String`和字符串Slice `&str`类型,而不仅仅是其中之一.虽然本部分内容大多是关于`String`的,不过这两个类型在Rust标准库中都被广泛使用,`String`和字符串Slice都是utf-8编码的.


很多`Vec`可用的操作在`String`中同样可用,从以`new`函数创建字符串开始.通常字符串都有初始数据,因为我们希望一开始就有这个字符串.为此可以使用`to_string`方法,它能用于任何实现在`Display` trait的类型,字符串字面值也实现了它.也可以使用`String::from`函数从字符串字面值创建`String`.

因为字符串应用广泛,这里有很多不同的用于字符串的通用API可供选择.它们有些可能显示有些多余,不过都有其用武之地!`String::from`和.`to_string`最终做了完全相同的工作,所以如何选择就是风格问题了.

记住字符串是UTF-8编码的,所以可以包含任何可以正确编码的数据.

```rust
let mut s1=String::from("foo");
let s2="bar";
println!("s2 is{}",s2);
```
*示例:1*

如果`push_str`方法获取了`s2`的所有权,就不能在最后一行打印出其值了.好在代码如我们期望那样工作!

通常你会希望将两个已知的字符串合并在一起.一种方法是像这样使用`+`运算符:
```rust
let s1=String::from("hello, ");
let s2=String::from("world!");
let s3=s1+&s2;//注意s1被移动了,不能继续使用
```
*示例:2*

执行完这些代码之后字符串`s3`将包含`hello, world!`.`s1`在相加后不再有效的原因,和使用s2的引用的原因使用+运算符调用的方法签名有关,这个函数签名看起来像这样:
```rust
fn add(self,s:&str)->String{}
```
这并不是标准库中实际的签名;标准库中的`add`使用泛型定义.这里我们看到`add`的签名使用具体类型代替了泛型,这也正是使用`String`值调用这个方法会发生的.

首先,`s2`使用了&,意味着我们使用第二个字符串的引用与第一个字符串相加.这是因为`add`函数的`s`参数:只能将`&str`和`String`相加,不能将两个`String`值相加.不过等一下---正如`add`的第二个参数所指定的,`&s2`的类型是`&String`而不是`&str`.那么为什么示例还能编辑呢?


之所以能够在`add`调用中使用`&s2`是因为`&String`**可能被强转**(*Coerced*)成`&str`.当`add`函数被调用时,Rust使用了一个被称为**解引用强制多态**(*deref coercion*)的技术,你可以将其理解为把`&s2`变成了`&s2[..]`.第十五章会更深入的讨论解引用强制多态.因为`add`没有获取参数的所有权,所以s2在这个操作后依然是有效的`String`.

其次,可以发现签名中`add`获取的`self`的所有权,因为`self`没有使用&.这意味着`s1`的所有权会被移动到`add`调用中.之后就不再有效.所以虽然`let s3=s1+&s2;`看起来就像它会复制两个字符串并创建一个新字符串,而实际上这个语句会获取`s1`的所有权,附加上从`s2`的拷贝内容.并返回结果的所有权.换句话说,它看起来好像生成了很多拷贝不过实际上并没有:这个实现比拷贝要更高效.

在很多语言中,通过索引来引用字符串中的单独字符是有效且常用的操作.然而在Rust中,如果你尝试使用索引语法访问`String`的一部分,会出现一个错误.(Rust的字符串不支持索引,那么接下来的问题是,为什么不支持呢?为了回答这个问题,我们必须先聊一聊Rust是如何在内存中储存字符串的.)

`String`是一个`Vec<u8>`封装.让我们看看之前一些正确编码的字符串的例子.首先是这一个:
```rust
let len=String::from("hola").len();
```
*示例:3*

在这里,`len`的值是4,这意味着储存字符串"hola"的`vec`的长度是四个字节:这里第一个字母的UTF-8编码都占用一个字节.那下面的这个例子双双如何呢?()

当问及这个字符串是多长的时候有人可能会说是12.然而,Rust的回答是24.这是使用UTF-8编码"Здравствуйте"所需要的字节数,这是因为每个Unicode标量值需要两个字节存储.因此一个字符串字节值的索引并不总是对应一个有效的Unicode标量值.

事实上有三种相关方式可能理解字符串:**字节**,**标量值**,**字形簇**(*最接近人们字母的概念*).

Rust提供了多种不同的方式来解释计算机存储的原始字符串数据,这样程序就可以选择它需要的表现方式,而无所谓是何种人类语言.

最后一个Rust不允许使用索引获取`String`字符的原因是索引操作预期问题需要常数时间`(O(1))`.但是对于`String`不可能保证这样的性能,因为Rust不得不检查从字符串开头对索引位置的内容来确定这里有多少有效的字符.


